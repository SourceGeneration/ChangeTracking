using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace SourceGeneration.States.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class StateInjectSourceGenerator : IIncrementalGenerator
{
    public const string RootNamespace = "SourceGeneration.States";
    public const string StateAttribute = $"{RootNamespace}.StateInjectAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
            StateAttribute,
            predicate: static (node, token) =>
            {
                if (node is TypeDeclarationSyntax type
                    //|| method.IsAbstract()
                    && type.IsPublic()
                    && !type.IsAbstract()
                    && type.TypeParameterList == null)
                {
                    return true;
                }

                return false;
            },
            transform: static (context, token) =>
            {
                return (TypeDeclarationSyntax)context.TargetNode;
            });

        var source = methodDeclarations.Collect().Combine(context.CompilationProvider);

        context.RegisterSourceOutput(source, static (sourceContext, source) =>
        {
            CancellationToken cancellationToken = sourceContext.CancellationToken;
            ImmutableArray<TypeDeclarationSyntax> types = source.Left;
            Compilation compilation = source.Right;

            if (types.Length == 0)
                return;

            CSharpCodeBuilder builder = new();

            builder.AppendAutoGeneratedComment();
            builder.AppendBlock("internal static class ___StateInitializer", () =>
            {
                builder.AppendLine("[global::System.Runtime.CompilerServices.ModuleInitializer]");
                builder.AppendBlock("public static void Initialize()", () =>
                {
                    foreach (var tree in types.GroupBy(x=>x.SyntaxTree))
                    {
                        var model = compilation.GetSemanticModel(tree.Key);

                        foreach (var type in tree)
                        {
                            var typeSymbol = (ITypeSymbol)model.GetDeclaredSymbol(type, cancellationToken)!;

                            var injectState = GenerateProxy(typeSymbol);
                            if (injectState != null)
                            {
                                builder.AppendLine(injectState);
                            }
                        }
                    }
                });
            });
            sourceContext.AddSource($"{RootNamespace}.___SourceGeneration.StateInjectInitializer.g.cs", builder.ToString());

        });
    }

    private static string? GenerateProxy(ITypeSymbol stateModel)
    {
        var attribute = stateModel.GetAttribute(StateAttribute);

        if (attribute == null)
        {
            return null;
        }

        var ns = stateModel.GetNamespace();

        if (attribute.ConstructorArguments.Length == 0)
        {
            return $"global::{RootNamespace}.StateRegister.Add<{ns}.{stateModel.Name}>();";
        }
        else if (attribute.ConstructorArguments.Length == 1)
        {
            return (int)attribute.ConstructorArguments[0].Value! switch
            {
                0 => $"global::{RootNamespace}.StateRegister.Add<{ns}.{stateModel.Name}>(global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton);",
                1 => $"global::{RootNamespace}.StateRegister.Add<{ns}.{stateModel.Name}>(global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped);",
                _ => $"global::{RootNamespace}.StateRegister.Add<{ns}.{stateModel.Name}>(global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Transient);",
            };
        }

        return null;

    }
}
